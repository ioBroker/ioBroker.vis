{"version":3,"file":"static/js/466.be5db21b.chunk.js","mappings":"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","sources":["Store.tsx","Utils/utils.tsx","Vis/visLoadWidgets.tsx","Vis/visUtils.tsx","Vis/visWidgetsCatalog.tsx"],"sourcesContent":["import {\n    createReducer, configureStore, createAction, createSelector,\n} from '@reduxjs/toolkit';\nimport type {\n    View, Project, AnyWidgetId, SingleWidgetId, SingleWidget, GroupWidget, GroupWidgetId,\n} from '@/types';\n\n/** This id is used by some special widgets to work with non-existing widgets */\nconst FAKE_ID = 'fakeId';\n\nexport const updateProject = createAction<Project>('project/update');\nexport const updateView = createAction<{ viewId: string; data: View }>('view/update');\nexport const updateWidget = createAction<{ viewId: string; widgetId: GroupWidgetId | SingleWidgetId | typeof FAKE_ID; data: SingleWidget }>('widget/update');\nexport const updateGroupWidget = createAction<{ viewId: string; widgetId: GroupWidgetId | typeof FAKE_ID; data: GroupWidget }>('group/update');\nexport const updateActiveUser = createAction<string>('activeUser/update');\nexport const recalculateFields = createAction<boolean>('attributes/recalculate');\n\nconst initialState = {\n    visProject: {} as Project,\n    /** If fields need to be recalculated on next render */\n    recalculateFields: false,\n    /** Logged in user */\n    activeUser: '',\n};\n\nconst reducer = createReducer(\n    initialState,\n    builder => {\n        builder\n            .addCase(updateProject, (state, action) => {\n                state.visProject = action.payload as Project;\n            })\n            .addCase(updateView, (state, action) => {\n                const { viewId, data } = action.payload;\n                state.visProject[viewId] = data;\n            })\n            .addCase(updateWidget, (state, action) => {\n                const { viewId, widgetId, data } = action.payload;\n                if (widgetId === FAKE_ID) {\n                    // Ignore it\n                    return;\n                }\n\n                if (!(viewId in state.visProject)) {\n                    console.error(`Cannot update widget \"${widgetId}\". The view \"${viewId}\" does not exist in the project.`);\n                    return;\n                }\n\n                state.visProject[viewId].widgets[widgetId as SingleWidgetId] = data;\n            })\n            .addCase(updateGroupWidget, (state, action) => {\n                const { viewId, widgetId, data } = action.payload;\n\n                if (widgetId === FAKE_ID) {\n                    // Ignore it\n                    return;\n                }\n\n                if (!(viewId in state.visProject)) {\n                    console.error(`Cannot update group widget \"${widgetId}\". The view \"${viewId}\" does not exist in the project.`);\n                    return;\n                }\n\n                state.visProject[viewId].widgets[widgetId] = data;\n            })\n            .addCase(updateActiveUser, (state, action) => {\n                state.activeUser = action.payload;\n            })\n            .addCase(recalculateFields, (state, action) => {\n                state.recalculateFields = action.payload;\n            });\n    },\n);\n\ntype StoreState = typeof initialState\n\nexport const selectProject = (state: StoreState) => state.visProject;\n\nexport const selectView = createSelector([\n    selectProject,\n    (_state: StoreState, viewName: string) => viewName,\n], (project, view) => project[view]);\n\nexport const selectWidget = createSelector([\n    selectView,\n    (_state: StoreState, _viewName: string, wid: AnyWidgetId) => wid,\n], (view, wid) => view.widgets[wid]);\n\nexport const store = configureStore({\n    reducer,\n});\n","/**\n * This file contains shared utils between edit and runtime\n */\nimport type { CSSProperties } from '@mui/styles';\nimport { store } from '@/Store';\nimport {\n    GroupWidget, Widget, Project, SingleWidget, SingleWidgetId, GroupWidgetId, AnyWidgetId, Permissions,\n} from '@/types';\n\n/** Default OID if no selected */\nexport const NOTHING_SELECTED = 'nothing_selected';\n\n/**\n * Adds an overflow visible attribute if no specific overflow is present,\n * else it deletes the general overflow, so the specific one can take effect\n *\n * @param style the style to modify\n */\nexport function calculateOverflow(style: CSSProperties): void {\n    if (!style.overflowX && !style.overflowY) {\n        style.overflow = 'visible';\n    } else if (style.overflow) {\n        delete style.overflow;\n    }\n}\n\n/**\n * Check, that given number is not Infinity or NaN\n *\n * @param numberOrString number or string to check\n */\nexport function isVarFinite(numberOrString: number | string | undefined): boolean {\n    // the difference between Number.isFinite and window.isFinite is that window.isFinite tries to convert the parameter to a number\n    // and Number.isFinite does not and just check against non NaN and non Infinity\n\n    // eslint-disable-next-line no-restricted-properties\n    return window.isFinite(numberOrString as number);\n}\n\n/**\n * Check if passed Widget is a group\n *\n * @param widget widget to check\n */\nexport function isGroup(widget: Widget): widget is GroupWidget {\n    return widget.tpl === '_tplGroup';\n}\n\n/**\n * Stringify-parse copy with type inference\n *\n * @param object The object which should be cloned\n */\nexport function deepClone<T extends Record<string, any>>(object: T): T {\n    return JSON.parse(JSON.stringify(object));\n}\n\n/**\n * Get next widgetId as a number\n *\n * @param isWidgetGroup if it is a group of widgets\n * @param project current project\n * @param offset offset if multiple widgets are created and not yet in project\n */\nexport function getNewWidgetIdNumber(isWidgetGroup: boolean, project: Project, offset = 0): number  {\n    const widgets: string[] = [];\n    project = project || store.getState().visProject;\n    Object.keys(project).forEach(view =>\n        project[view].widgets && Object.keys(project[view].widgets).forEach(widget =>\n            widgets.push(widget)));\n    let newKey = 1;\n    widgets.forEach(name => {\n        const matches = isWidgetGroup ? name.match(/^g([0-9]+)$/) : name.match(/^w([0-9]+)$/);\n        if (matches) {\n            const num = parseInt(matches[1], 10);\n            if (num >= newKey) {\n                newKey = num + 1;\n            }\n        }\n    });\n\n    return newKey + offset;\n}\n\n/**\n * Get new widget id from the project\n * @param project project to determine next widget id for\n * @param offset offset, if multiple widgets are created and not yet in the project\n */\nexport function getNewWidgetId(project: Project, offset = 0): SingleWidgetId {\n    const newKey = getNewWidgetIdNumber(false, project, offset);\n\n    return `w${(newKey).toString().padStart(6, '0')}`;\n}\n\n/**\n * Get new group id from the project\n * @param project project to determine next group id for\n * @param offset offset, if multiple groups are created and not yet in the project\n */\nexport function getNewGroupId(project: Project, offset = 0): GroupWidgetId {\n    const newKey = getNewWidgetIdNumber(true, project, offset);\n\n    return `g${newKey.toString().padStart(6, '0')}`;\n}\n\ninterface CopyWidgetOptions {\n    /** The widgets key, value object to copy the group to */\n    widgets: Record<string, Widget>;\n    /** The offset to use, if multiple groups are copied without saving */\n    offset?: number;\n    /** The project to calculate new widget ids from */\n    project: Project;\n}\n\ninterface CopySingleWidgetOptions extends CopyWidgetOptions {\n    /** The widget which should be copied */\n    widget: SingleWidget;\n    /** ID of the selected group if one is active */\n    selectedGroup?: GroupWidgetId;\n}\n\ninterface CopyGroupOptions extends CopyWidgetOptions {\n    /** The group which should be copied */\n    group: GroupWidget;\n    /** The group member widgets stored in the clipboard to paste from */\n    groupMembers: Record<string, Widget>;\n}\n\n/**\n * Paste a single widget into the given widgets key, value object\n * Returns the new widget id\n *\n * @param options selected group, widgets and offset information\n */\nexport function pasteSingleWidget(options: CopySingleWidgetOptions): string {\n    const  {\n        widgets, offset, project, widget, selectedGroup,\n    } = options;\n\n    const newKey = getNewWidgetId(project, offset);\n\n    if (selectedGroup && isGroup(widgets[selectedGroup])) {\n        widget.grouped = true;\n        widget.groupid = selectedGroup;\n        (widgets[selectedGroup] as GroupWidget).data.members.push(newKey);\n    }\n\n    widgets[newKey] = widget;\n\n    return newKey;\n}\n\n/**\n * Paste a group and all the members into the given widgets key, value object\n * Returns the new group id\n *\n * @param options group, widgets and offset information\n */\nexport function pasteGroup(options: CopyGroupOptions): string {\n    const  {\n        widgets, group, groupMembers, offset, project,\n    } = options;\n    const newGroupId = getNewGroupId(project, offset ?? 0);\n\n    for (let i = 0; i < group.data.members.length; i++) {\n        const wid = group.data.members[i];\n        const newMember = deepClone(groupMembers[wid]);\n\n        const newMemberId = getNewWidgetId(project, i);\n\n        newMember.groupid = newGroupId;\n        group.data.members[i] = newMemberId;\n        widgets[newMemberId] = newMember;\n    }\n\n    widgets[newGroupId] = group;\n\n    return newGroupId;\n}\n\n/**\n * Removes all special structures from the project\n *\n * @param project the project to remove special structures from\n */\nexport function unsyncMultipleWidgets(project: Project): Project {\n    project = deepClone(project || store.getState().visProject);\n    for (const  [viewName, view] of Object.entries(project)) {\n        if (viewName === '___settings') {\n            continue;\n        }\n\n        for (const widgetId of Object.keys(view.widgets)) {\n            if (widgetId.includes('_')) {\n                delete view.widgets[widgetId as AnyWidgetId];\n            }\n        }\n    }\n\n    return project;\n}\n\ninterface CheckAccessOptions {\n    /** The project the user wants to access */\n    project: Project;\n    /** The active user */\n    user: string;\n    /** True if running in edit mode */\n    editMode: boolean;\n}\n\n/** Default permissions if no given, user has full access */\nexport const DEFAULT_PERMISSIONS: Permissions = { read: true, write: true };\n\n/**\n * Check if the user has access to the project in given mode\n *\n * @param options project, user and mode information\n */\nexport function hasProjectAccess(options: CheckAccessOptions): boolean {\n    const { project, user, editMode } = options;\n\n    const permissions = project.___settings.permissions?.[user] ?? DEFAULT_PERMISSIONS;\n\n    if (editMode && permissions.write) {\n        return true;\n    }\n\n    return !editMode && permissions.read;\n}\n\ninterface CheckViewAccessOptions extends CheckAccessOptions{\n    /** Name of the view */\n    view: string;\n}\n\ninterface CheckWidgetAccessOptions extends CheckViewAccessOptions {\n    /** Widget ID */\n    wid: AnyWidgetId;\n}\n\n/**\n * Check if the user has access to the view in given mode\n *\n * @param options project, view, user and mode information\n */\nexport function hasViewAccess(options: CheckViewAccessOptions): boolean {\n    const {\n        project, user, editMode, view,\n    } = options;\n\n    const permissions = project[view]?.settings?.permissions?.[user] ?? DEFAULT_PERMISSIONS;\n\n    if (editMode && permissions.write) {\n        return true;\n    }\n\n    return !editMode && permissions.read;\n}\n\n/**\n * Check if the user has access to the widget in given mode\n *\n * @param options project, view, widget, user and mode information\n */\nexport function hasWidgetAccess(options: CheckWidgetAccessOptions): boolean {\n    const {\n        project, user, editMode, view, wid,\n    } = options;\n\n    const permissions = project[view]?.widgets[wid]?.permissions?.[user] ?? DEFAULT_PERMISSIONS;\n\n    if (editMode && permissions.write) {\n        return true;\n    }\n\n    return !editMode && permissions.read;\n}\n","/**\n *  ioBroker.vis\n *  https://github.com/ioBroker/ioBroker.vis\n *\n *  Copyright (c) 2024 Denis Haev https://github.com/GermanBluefox,\n *  Creative Common Attribution-NonCommercial (CC BY-NC)\n *\n *  http://creativecommons.org/licenses/by-nc/4.0/\n *\n * Short content:\n * Licensees may copy, distribute, display and perform the work and make derivative works based on it only if they give the author or licensor the credits in the manner specified by these.\n * Licensees may copy, distribute, display, and perform the work and make derivative works based on it only for noncommercial purposes.\n * (Free for non-commercial use).\n */\nimport { I18n, type LegacyConnection } from '@iobroker/adapter-react-v5';\nimport type VisRxWidget from '@/Vis/visRxWidget';\n\ntype WidgetSetName = string;\ntype PromiseName = `_promise_${WidgetSetName}`;\ndeclare global {\n    interface Window {\n        [promiseName: PromiseName]: Promise<any>;\n        [widgetSetName: WidgetSetName]: {\n            __initialized: boolean;\n            get: (module: string) => () => void;\n            init?: (shareScope: any) => Promise<void>;\n        };\n    }\n}\nconst getOrLoadRemote = (remote: string, shareScope: string | { default: any }, remoteFallbackUrl?: string): Promise<null> => {\n    window[`_promise_${remote}`] = window[`_promise_${remote}`] || new Promise((resolve, reject) => {\n        // check if remote exists on window\n        // search dom to see if remote tag exists, but might still be loading (async)\n        const existingRemote = document.querySelector(`[data-webpack=\"${remote}\"]`);\n        // when remote is loaded...\n        const onload = async () => {\n            // check if it was initialized\n            if (!window[remote]) {\n                if (remoteFallbackUrl && (remoteFallbackUrl.startsWith('http://') || remoteFallbackUrl.startsWith('https://'))) {\n                    console.error(`Cannot load remote from url \"${remoteFallbackUrl}\"`);\n                } else {\n                    reject(new Error(`Cannot load ${remote} from ${remoteFallbackUrl}`));\n                }\n                resolve(null);\n                return;\n            }\n            if (!window[remote].__initialized) {\n                // if share scope doesn't exist (like in webpack 4) then expect shareScope to be a manual object\n                // eslint-disable-next-line camelcase\n                // @ts-expect-error this is a trick\n                if (typeof __webpack_share_scopes__ === 'undefined' && window[remote].init) {\n                    // use the default share scope object, passed in manually\n                    // @ts-expect-error no idea why\n                    await window[remote].init((shareScope as { default: any })?.default);\n                } else if (window[remote].init) {\n                    // otherwise, init share scope as usual\n\n                    try {\n                        // eslint-disable-next-line camelcase, no-undef\n                        // @ts-expect-error this is a trick\n                        await window[remote].init(__webpack_share_scopes__[shareScope]);\n                    } catch (e) {\n                        console.error(`Cannot init remote \"${remote}\" with \"${shareScope}\"`);\n                        console.error(e);\n                        reject(new Error(`Cannot init remote \"${remote}\" with \"${shareScope}\"`));\n                        reject(e);\n                        return;\n                    }\n                } else {\n                    reject(new Error(`Remote init function not found for ${remote} from ${remoteFallbackUrl}`));\n                    return;\n                }\n                // mark remote as initialized\n                window[remote].__initialized = true;\n            }\n            // resolve promise so marking remote as loaded\n            resolve(null);\n        };\n        if (existingRemote) {\n            console.warn(`SOMEONE IS LOADING THE REMOTE ${remote}`);\n            // if existing remote but not loaded, hook into its onload and wait for it to be ready\n            // existingRemote.onload = onload;\n            // existingRemote.onerror = reject;\n            resolve(null);\n            // check if remote fallback exists as param passed to function\n            // TODO: should scan public config for a matching key if no override exists\n        } else if (remoteFallbackUrl) {\n            // inject remote if a fallback exists and call the same onload function\n            const d = document;\n            const script = d.createElement('script');\n            script.type = 'text/javascript';\n            // mark as data-webpack so runtime can track it internally\n            script.setAttribute('data-webpack', `${remote}`);\n            script.async = true;\n            script.onerror = () => {\n                if (!remoteFallbackUrl.includes('iobroker.net')) {\n                    reject(new Error(`Cannot load ${remote} from ${remoteFallbackUrl}`));\n                } else {\n                    resolve(null);\n                }\n            };\n            script.onload = onload;\n            script.src = remoteFallbackUrl;\n            d.getElementsByTagName('head')[0].appendChild(script);\n        } else {\n            // no remote and no fallback exist, reject\n            reject(new Error(`Cannot Find Remote ${remote} to inject`));\n        }\n    });\n\n    return window[`_promise_${remote}`];\n};\n\nexport const loadComponent = (remote: WidgetSetName, sharedScope: string, module: string, url: string): (() => any) =>\n    () => getOrLoadRemote(remote, sharedScope, url)\n        .then(() => window[remote] && window[remote].get(module))\n        .then(factory => factory && factory());\n\nfunction registerWidgetsLoadIndicator(cb: (process: number, max: number) => void) {\n    window.__widgetsLoadIndicator = cb;\n}\n\ninterface VisLoadComponentContext {\n    visWidgetsCollection: ioBroker.VisWidget;\n    countRef: { count: number; max: number };\n    dynamicWidgetInstance: ioBroker.InstanceObject;\n    i18nPrefix: string;\n    // List of custom React components\n    result: VisRxWidget<any>[];\n}\n\nfunction _loadComponentHelper(context: VisLoadComponentContext): Promise<void[]> {\n    // expected in context\n    // visWidgetsCollection\n    // countRef\n    // dynamicWidgetInstance\n    // i18nPrefix\n    // result\n    const promises: Promise<void>[] = [];\n\n    for (let i = 0; i < context.visWidgetsCollection.components.length; i++) {\n        ((index: number, _visWidgetsCollection) => {\n            context.countRef.max++;\n\n            const promise = loadComponent(_visWidgetsCollection.name, 'default', `./${_visWidgetsCollection.components[index]}`, _visWidgetsCollection.url)()\n                .then((CustomComponent: any) => {\n                    context.countRef.count++;\n\n                    if (CustomComponent.default) {\n                        CustomComponent.default.adapter = context.dynamicWidgetInstance._id.substring('system.adapter.'.length).replace(/\\.\\d*$/, '');\n                        CustomComponent.default.version = context.dynamicWidgetInstance.common.version;\n                        CustomComponent.default.url = _visWidgetsCollection.url;\n                        if (context.i18nPrefix) {\n                            CustomComponent.default.i18nPrefix = context.i18nPrefix;\n                        }\n                        context.result.push(CustomComponent.default);\n                    } else {\n                        console.error(`Cannot load widget ${context.dynamicWidgetInstance._id}. No default found`);\n                    }\n                    window.__widgetsLoadIndicator && window.__widgetsLoadIndicator(context.countRef.count, context.countRef.max);\n                })\n                .catch((e: any) => {\n                    console.error(`Cannot load widget ${context.dynamicWidgetInstance._id}: ${e.toString()}`);\n                    console.error(`Cannot load widget ${context.dynamicWidgetInstance._id}: ${JSON.stringify(e)}`);\n                });\n\n            promises.push(promise);\n        })(i, context.visWidgetsCollection);\n    }\n\n    return Promise.all(promises);\n}\n\nfunction getText(text: string | ioBroker.StringOrTranslated): string {\n    if (typeof text === 'object') {\n        return text[I18n.getLanguage()] || text.en || '';\n    }\n    return (text || '').toString();\n}\n\n/* Do not make this funktion async, because is optimized to simultaneously load the widget sets */\nfunction getRemoteWidgets(socket: LegacyConnection, onlyWidgetSets?: false | string[]): Promise<void | VisRxWidget<any>[]> {\n    return socket.getObjectViewSystem(\n        'instance',\n        'system.adapter.',\n        'system.adapter.\\u9999',\n    )\n        .then(objects => {\n            const result: VisRxWidget<any>[] = [];\n            const countRef = { count: 0, max: 0 };\n            const instances: ioBroker.InstanceObject[] = Object.values(objects as Record<string, ioBroker.InstanceObject>);\n            const dynamicWidgetInstances: ioBroker.InstanceObject[] = instances.filter(obj  => {\n                if (!(obj as ioBroker.InstanceObject).common.visWidgets) {\n                    return false;\n                }\n                const ignoreVersions: number[] = ((obj as ioBroker.InstanceObject).common.visWidgets as any).ignoreInVersions || [];\n                return !ignoreVersions.includes(2) &&\n                    (!onlyWidgetSets || onlyWidgetSets.includes(getText((obj as ioBroker.InstanceObject).common.name)));\n            });\n\n            const promises: Promise<void[] | void | null>[] = [];\n            for (let i = 0; i < dynamicWidgetInstances.length; i++) {\n                const dynamicWidgetInstance = dynamicWidgetInstances[i];\n                for (const widgetSetName in dynamicWidgetInstance.common.visWidgets) {\n                    // deprecated\n                    if (widgetSetName === 'i18n') {\n                        // ignore\n                        // find first widget set that is not i18n\n                        const _widgetSetName = Object.keys(dynamicWidgetInstance.common.visWidgets).find(name => name !== 'i18n');\n                        console.warn(`common.visWidgets.i18n is deprecated. Use common.visWidgets.${_widgetSetName}.i18n instead.`);\n                    } else {\n                        const visWidgetsCollection: ioBroker.VisWidget = dynamicWidgetInstance.common.visWidgets[widgetSetName];\n                        if (!visWidgetsCollection.url?.startsWith('http')) {\n                            visWidgetsCollection.url = `./widgets/${visWidgetsCollection.url}`;\n                        }\n                        if (visWidgetsCollection.components) {\n                            ((collection, instance) => {\n                                try {\n                                    let i18nPrefix = '';\n                                    let i18nPromiseWait: Promise<void | null> | undefined;\n\n                                    // 1. Load language file ------------------\n                                    // instance.common.visWidgets.i18n is deprecated\n                                    if (collection.url && collection.i18n === true) {\n                                        // load i18n from files\n                                        const pos = collection.url.lastIndexOf('/');\n                                        let i18nURL: string;\n                                        if (pos !== -1) {\n                                            i18nURL = collection.url.substring(0, pos);\n                                        } else {\n                                            i18nURL = collection.url;\n                                        }\n                                        const lang = I18n.getLanguage();\n\n                                        i18nPromiseWait = fetch(`${i18nURL}/i18n/${lang}.json`)\n                                            .then(data => data.json())\n                                            .then(json => {\n                                                countRef.count++;\n                                                I18n.extendTranslations(json, lang);\n                                                window.__widgetsLoadIndicator && window.__widgetsLoadIndicator(countRef.count, promises.length);\n                                            })\n                                            .catch(error => {\n                                                if (lang !== 'en') {\n                                                    // try to load English\n                                                    return fetch(`${i18nURL}/i18n/en.json`)\n                                                        .then(data => data.json())\n                                                        .then(json => {\n                                                            countRef.count++;\n                                                            I18n.extendTranslations(json, lang);\n                                                            window.__widgetsLoadIndicator && window.__widgetsLoadIndicator(countRef.count, promises.length);\n                                                        })\n                                                        .catch(_error => console.log(`Cannot load i18n \"${i18nURL}/i18n/${lang}.json\": ${_error}`));\n                                                }\n                                                console.log(`Cannot load i18n \"${i18nURL}/i18n/${lang}.json\": ${error}`);\n                                                return null;\n                                            });\n                                        promises.push(i18nPromiseWait);\n                                    } else if (collection.url && collection.i18n === 'component') {\n                                        // instance.common.visWidgets.i18n is deprecated\n                                        i18nPromiseWait = loadComponent(collection.name, 'default', './translations', collection.url)()\n                                            .then((translations: any) => {\n                                                countRef.count++;\n\n                                                // add automatic prefix to all translations\n                                                if (translations.default.prefix === true) {\n                                                    translations.default.prefix = `${instance.common.name}_`;\n                                                }\n                                                i18nPrefix = translations.default.prefix;\n\n                                                I18n.extendTranslations(translations.default);\n                                                window.__widgetsLoadIndicator && window.__widgetsLoadIndicator(countRef.count, promises.length);\n                                            })\n                                            .catch((error: string) =>\n                                                console.log(`Cannot load i18n \"${collection.name}\": ${error}`));\n                                    } else if (collection.i18n && typeof collection.i18n === 'object') {\n                                        try {\n                                            I18n.extendTranslations(collection.i18n);\n                                        } catch (error) {\n                                            console.error(`Cannot import i18n: ${error}`);\n                                        }\n                                    }\n\n                                    // 2. Load all components ------------------\n                                    if (collection.components) {\n                                        if (i18nPromiseWait) {\n                                            // we must wait for it as the flag i18nPrefix will be used in the component\n                                            promises.push(i18nPromiseWait\n                                                .then(() => _loadComponentHelper({\n                                                    visWidgetsCollection: collection,\n                                                    countRef,\n                                                    dynamicWidgetInstance: instance,\n                                                    i18nPrefix,\n                                                    result,\n                                                })));\n                                        } else {\n                                            // do not wait for languages\n                                            promises.push(_loadComponentHelper({\n                                                visWidgetsCollection: collection,\n                                                countRef,\n                                                dynamicWidgetInstance: instance,\n                                                i18nPrefix,\n                                                result,\n                                            }));\n                                        }\n                                    } else if (i18nPromiseWait) {\n                                        promises.push(i18nPromiseWait);\n                                    }\n                                } catch (e) {\n                                    console.error(e);\n                                }\n                            })(visWidgetsCollection, dynamicWidgetInstance);\n                        }\n                    }\n                }\n            }\n\n            return Promise.all(promises)\n                .then(() => result);\n        })\n        .catch(e => console.error('Cannot read instances', e));\n}\n\nexport {\n    getRemoteWidgets,\n    registerWidgetsLoadIndicator,\n};\n","/**\n *  ioBroker.vis\n *  https://github.com/ioBroker/ioBroker.vis\n *\n *  Copyright (c) 2022-2024 Denis Haev https://github.com/GermanBluefox,\n *  Creative Common Attribution-NonCommercial (CC BY-NC)\n *\n *  http://creativecommons.org/licenses/by-nc/4.0/\n *\n * Short content:\n * Licensees may copy, distribute, display and perform the work and make derivative works based on it only if they give the author or licensor the credits in the manner specified by these.\n * Licensees may copy, distribute, display, and perform the work and make derivative works based on it only for noncommercial purposes.\n * (Free for non-commercial use).\n */\nimport { type LegacyConnection } from '@iobroker/adapter-react-v5';\nimport {\n    Project,\n    AnyWidgetId,\n    GroupWidgetId,\n    VisStateUsage,\n    VisLinkContextBinding,\n    StateID, VisBindingOperation, VisBindingOperationArgument,\n    GroupData, WidgetData, VisBinding, VisBindingOperationType,\n    RxWidgetInfoAttributesFieldID,\n} from '@/types';\nimport { deepClone } from '@/Utils/utils';\nimport { store, updateView, updateWidget } from '@/Store';\n\ndeclare global {\n    interface Window {\n        __widgetsLoadIndicator: (process: number, max: number) => void;\n    }\n}\n\nfunction replaceGroupAttr(inputStr: string, groupAttrList: WidgetData): { doesMatch: boolean; newString: string } {\n    let newString = inputStr;\n    let match = false;\n    // old style: groupAttr0, groupAttr1, groupAttr2, ...\n    let ms = inputStr.match(/(groupAttr\\d+)+?/g);\n    if (ms) {\n        match = true;\n        ms.forEach(m => {\n            const val = groupAttrList[m];\n            if (val === null || val === undefined) {\n                newString = newString.replace(/groupAttr(\\d+)/, '');\n            } else {\n                newString = newString.replace(/groupAttr(\\d+)/, groupAttrList[m]);\n            }\n        });\n    }\n\n    // new style: %html%, %myAttr%, ...\n    ms = inputStr.match(/%([-_a-zA-Z\\d]+)+?%/g);\n    if (ms) {\n        match = true;\n        ms.forEach((m: string) => {\n            const attr = m.substring(1, m.length - 1);\n            const val = groupAttrList[attr];\n            if (val === null || val === undefined) {\n                newString = newString.replace(m, '');\n            } else {\n                newString = newString.replace(m, val);\n            }\n        });\n    }\n\n    return { doesMatch: match, newString };\n}\n\nfunction getWidgetGroup(views: Project, view: string, widget: AnyWidgetId): GroupWidgetId | undefined {\n    const widgets = views[view].widgets;\n    const groupId: GroupWidgetId | undefined = widgets[widget]?.groupid;\n    if (groupId && widgets[groupId]) {\n        return views[view].widgets[widget].groupid;\n    }\n    const widgetKeys: AnyWidgetId[] = Object.keys(widgets) as AnyWidgetId[];\n    return widgetKeys.find(w => widgets[w].data?.members?.includes(widget)) as GroupWidgetId;\n}\n\n/**\n * Determine if the string is of form identifier:ioBrokerId, like, val:hm-rpc.0.device.channel.state\n */\nfunction isIdBinding(\n    /** the possible assignment to check */\n    assignment: string,\n): boolean {\n    return !!assignment.match(/^[\\d\\w_]+:\\s?[-.\\d\\w_#]+$/);\n}\n\nfunction extractBinding(format: string): VisBinding[] | null {\n    const oid = format.match(/{(.+?)}/g);\n    let result: VisBinding[] | null = null;\n\n    if (oid) {\n        if (oid.length > 50) {\n            console.warn(`Too many bindings in one widget: ${oid.length}[max = 50]`);\n        }\n\n        for (let p = 0; p < oid.length && p < 50; p++) {\n            const _oid = oid[p].substring(1, oid[p].length - 1);\n            if (_oid[0] === '{') {\n                continue;\n            }\n            // If the first symbol is '\"' => it is JSON\n            if (_oid && _oid[0] === '\"') {\n                continue;\n            }\n            const parts = _oid.split(';');\n            result = result || [];\n            let systemOid = parts[0].trim();\n            let visOid = systemOid;\n\n            let test1 = visOid.substring(visOid.length - 4).trim();\n            let test2 = visOid.substring(visOid.length - 3).trim();\n\n            if (visOid && test1 !== '.val' && test2 !== '.ts' && test2 !== '.lc' && test1 !== '.ack') {\n                visOid += '.val';\n            }\n\n            const isSeconds = test2 === '.ts' || test2 === '.lc';\n\n            test1 = systemOid.substring(systemOid.length - 4);\n            test2 = systemOid.substring(systemOid.length - 3);\n\n            if (test1 === '.val' || test1 === '.ack') {\n                systemOid = systemOid.substring(0, systemOid.length - 4);\n            } else if (test2 === '.lc' || test2 === '.ts') {\n                systemOid = systemOid.substring(0, systemOid.length - 3);\n            }\n            let operations: VisBindingOperation[] | null = null;\n            const isEval = visOid.match(/^[\\d\\w_]+:\\s?[-._/ :!#$%&()+=@^{}|~\\p{Ll}\\p{Lu}\\p{Nd}]+$/u) || (!visOid.length && parts.length > 0); // (visOid.indexOf(':') !== -1) && (visOid.indexOf('::') === -1);\n\n            if (isEval) {\n                const xx = visOid.split(':', 2);\n                const yy = systemOid.split(':', 2);\n                visOid = xx[1].trim();\n                systemOid = yy[1].trim();\n                operations = [];\n                operations.push({\n                    op: 'eval',\n                    arg: [{\n                        name: xx[0],\n                        visOid,\n                        systemOid,\n                    }],\n                });\n\n                for (let u = 1; u < parts.length; u++) {\n                    // eval construction\n                    const trimmed = parts[u].trim();\n                    if (isIdBinding(trimmed)) { // parts[u].indexOf(':') !== -1 && parts[u].indexOf('::') === -1) {\n                        const argParts = trimmed.split(':', 2);\n                        let _visOid = argParts[1].trim();\n                        let _systemOid = _visOid;\n\n                        test1 = _visOid.substring(_visOid.length - 4);\n                        test2 = _visOid.substring(_visOid.length - 3);\n\n                        if (test1 !== '.val' && test2 !== '.ts' && test2 !== '.lc' && test1 !== '.ack') {\n                            _visOid += '.val';\n                        }\n\n                        test1 = _systemOid.substring(_systemOid.length - 4);\n\n                        if (test1 === '.val' || test1 === '.ack') {\n                            _systemOid = _systemOid.substring(0, _systemOid.length - 4);\n                        } else {\n                            test2 = _systemOid.substring(_systemOid.length - 3);\n                            if (test2 === '.lc' || test2 === '.ts') {\n                                _systemOid = _systemOid.substring(0, _systemOid.length - 3);\n                            }\n                        }\n\n                        (operations[0].arg as VisBindingOperationArgument[])?.push({\n                            name: argParts[0].trim(),\n                            visOid: _visOid,\n                            systemOid: _systemOid,\n                        });\n                    } else {\n                        parts[u] = parts[u].replace(/::/g, ':');\n                        if (operations[0].formula) {\n                            const n = deepClone(operations[0]);\n                            n.formula = parts[u];\n                            operations.push(n);\n                        } else {\n                            operations[0].formula = parts[u];\n                        }\n                    }\n                }\n            } else {\n                for (let u = 1; u < parts.length; u++) {\n                    const parse = parts[u].match(/([\\w\\s/+*-]+)(\\(.+\\))?/);\n                    if (parse && parse[1]) {\n                        const op = parse[1].trim();\n                        // operators requires parameter\n                        if (op === '*' ||\n                            op === '+' ||\n                            op === '-' ||\n                            op === '/' ||\n                            op === '%' ||\n                            op === 'min' ||\n                            op === 'max'\n                        ) {\n                            if (parse[2] === undefined) {\n                                console.log(`Invalid format of format string: ${format}`);\n                            } else {\n                                // try to extract number\n                                let argStr: string = (parse[2] || '').trim().replace(',', '.');\n                                argStr = argStr.substring(1, argStr.length - 1).trim();\n                                const arg: number = parseFloat(argStr);\n\n                                if (arg.toString() === 'NaN') {\n                                    console.log(`Invalid format of format string: ${format}`);\n                                } else {\n                                    operations = operations || [];\n                                    operations.push({ op, arg });\n                                }\n                            }\n                        } else if (op === 'date' || op === 'momentDate') {\n                            // date formatting\n                            operations = operations || [];\n                            let arg: string = (parse[2] || '').trim();\n                            // Remove braces from {momentDate(format)}\n                            arg = arg.substring(1, arg.length - 1);\n                            operations.push({ op, arg });\n                        } else if (op === 'array') {\n                            // returns array[value]. e.g.: {id.ack;array(ack is false,ack is true)}\n                            operations = operations || [];\n                            let param: string = (parse[2] || '').trim();\n                            param = param.substring(1, param.length - 1);\n                            operations.push({ op, arg: param.split(',') }); // xxx\n                        } else if (op === 'value') {\n                            // value formatting\n                            operations = operations || [];\n                            let arg: string = parse[2] === undefined ? '(2)' : (parse[2] || '');\n                            arg = arg.trim();\n                            arg = arg.substring(1, arg.length - 1);\n                            operations.push({ op, arg });\n                        } else if (op === 'pow' || op === 'round' || op === 'random') {\n                            // operators have optional parameter\n                            if (parse[2] === undefined) {\n                                operations = operations || [];\n                                operations.push({ op });\n                            } else {\n                                let argStr: string = (parse[2] || '').trim().replace(',', '.');\n                                argStr = argStr.substring(1, argStr.length - 1);\n                                const arg = parseFloat(argStr.trim());\n\n                                if (arg.toString() === 'NaN') {\n                                    console.log(`Invalid format of format string: ${format}`);\n                                } else {\n                                    operations = operations || [];\n                                    operations.push({ op, arg });\n                                }\n                            }\n                        } else if (op === 'json') {\n                            // json(objPropPath)  ex: json(prop1);  json(prop1.propA)\n                            operations = operations || [];\n                            let arg = (parse[2] || '').trim();\n                            arg = arg.substring(1, arg.length - 1);\n                            operations.push({ op, arg });\n                        } else {\n                            // operators without parameter\n                            operations = operations || [];\n                            operations.push({ op: op as VisBindingOperationType });\n                        }\n                    } else {\n                        console.log(`Invalid format ${format}`);\n                    }\n                }\n            }\n\n            result.push({\n                visOid,\n                systemOid,\n                token: oid[p],\n                operations: operations || undefined,\n                format,\n                isSeconds,\n            });\n        }\n    }\n\n    return result;\n}\n\n// outputs: {\n//    IDs: [],       //\n//    bindings: {},  //\n//    views: {},     //\n//    visibility: {} //\n//    signals: {}    //\n// }\nfunction getUsedObjectIDsInWidget(views: Project, view: string, wid: AnyWidgetId, linkContext: VisStateUsage) {\n    // Check all attributes\n    const widget = deepClone(views[view].widgets[wid]);\n\n    // fix error in naming\n    if (widget.groupped) {\n        widget.grouped = true;\n        delete widget.groupped;\n    }\n\n    // rename hqWidgets => hqwidgets\n    if (widget.widgetSet === 'hqWidgets') {\n        widget.widgetSet = 'hqwidgets';\n    }\n\n    // rename RGraph => rgraph\n    if (widget.widgetSet === 'RGraph') {\n        widget.widgetSet = 'rgraph';\n    }\n\n    // rename timeAndWeather => timeandweather\n    if (widget.widgetSet === 'timeAndWeather') {\n        widget.widgetSet = 'timeandweather';\n    }\n\n    // convert \"Show on Value\" to HTML\n    if (widget.tpl === 'tplShowValue') {\n        widget.tpl = 'tplHtml';\n        widget.data['visibility-oid'] = widget.data.oid;\n        widget.data['visibility-val'] = widget.data.value;\n        delete widget.data.oid;\n        delete widget.data.value;\n    }\n\n    // convert \"Hide on >0/True\" to HTML\n    if (widget.tpl === 'tplHideTrue') {\n        widget.tpl = 'tplHtml';\n        widget.data['visibility-cond'] = '!=';\n        widget.data['visibility-oid'] = widget.data.oid;\n        widget.data['visibility-val'] = true;\n        delete widget.data.oid;\n    }\n\n    // convert \"Hide on 0/False\" to HTML\n    if (widget.tpl === 'tplHide') {\n        widget.tpl = 'tplHtml';\n        widget.data['visibility-cond'] = '!=';\n        widget.data['visibility-oid'] = widget.data.oid;\n        widget.data['visibility-val'] = false;\n        delete widget.data.oid;\n    }\n\n    // convert \"Door/Window sensor\" to HTML\n    if (widget.tpl === 'tplHmWindow') {\n        widget.tpl = 'tplValueBool';\n        widget.data.html_false = widget.data.html_closed;\n        widget.data.html_true = widget.data.html_open;\n        delete widget.data.html_closed;\n        delete widget.data.html_open;\n    }\n\n    // convert \"Door/Window sensor\" to HTML\n    if (widget.tpl === 'tplHmWindowRotary') {\n        widget.tpl = 'tplValueListHtml8';\n        widget.data.count = 2;\n        widget.data.value0 = widget.data.html_closed;\n        widget.data.value1 = widget.data.html_open;\n        widget.data.value2 = widget.data.html_tilt;\n        delete widget.data.html_closed;\n        delete widget.data.html_open;\n        delete widget.data.html_tilt;\n    }\n\n    // convert \"tplBulbOnOff\" to tplBulbOnOffCtrl\n    if (widget.tpl === 'tplBulbOnOff') {\n        widget.tpl = 'tplBulbOnOffCtrl';\n        widget.data.readOnly = true;\n    }\n\n    // convert \"tplValueFloatBarVertical\" to tplValueFloatBar\n    if (widget.tpl === 'tplValueFloatBarVertical') {\n        widget.tpl = 'tplValueFloatBar';\n        widget.data.orientation = 'vertical';\n    }\n\n    let { data } = widget;\n    const { style } = widget;\n\n    // if widget is in the group => replace groupAttrX values\n    if (widget.grouped) {\n        // if groupid is not defined => fix it and find it\n        if (!widget.groupid) {\n            store.dispatch(updateWidget({\n                viewId: view,\n                widgetId: wid,\n                data: { ...widget, groupid: getWidgetGroup(views, view, wid) },\n            }));\n        }\n\n        // If the group, to which the widget belongs to does not exist, fix it\n        if (widget.groupid && !store.getState().visProject[view].widgets[widget.groupid]) {\n            store.dispatch(updateWidget({ viewId: view, widgetId: wid, data: { ...widget, groupid: getWidgetGroup(views, view, wid) } }));\n\n            if (!widget.groupid) {\n                // create a fictive group\n                let groupNum = 1;\n                let gId: GroupWidgetId = `g${groupNum.toString().padStart(5, '0')}`;\n                while (views[view].widgets[gId]) {\n                    groupNum++;\n                    gId = `g${groupNum.toString().padStart(5, '0')}`;\n                }\n\n                const currView = deepClone(views[view]);\n\n                currView.widgets[gId] = {\n                    tpl: '_tplGroup',\n                    data: {\n                        members: [wid],\n                    },\n                    style: {\n                        top: '100px',\n                        left: '100px',\n                        width: '200px',\n                        height: '200px',\n                    },\n                    widgetSet: null,\n                };\n\n                store.dispatch(updateView({ viewId: view, data: currView }));\n            }\n        }\n\n        if (widget.groupid) {\n            const parentWidgetData = views[view].widgets[widget.groupid]?.data;\n            if (parentWidgetData) {\n                let newGroupData: GroupData | undefined;\n\n                Object.keys(data).forEach(attr => {\n                    if (typeof data[attr] === 'string') {\n                        const result = replaceGroupAttr(data[attr], parentWidgetData);\n                        if (result.doesMatch) {\n                            newGroupData = newGroupData || (deepClone(data) as GroupData);\n                            newGroupData[attr] = result.newString || '';\n                        }\n                    }\n                });\n                if (newGroupData) {\n                    data = newGroupData;\n                }\n            } else {\n                console.error(`Invalid group id \"${widget.groupid}\" in widget \"${wid}\"`);\n            }\n        }\n    }\n\n    Object.keys(data || {}).forEach(attr => {\n        if (!attr) {\n            return;\n        }\n\n        if (typeof data[attr] === 'string') {\n            let m;\n            // Process bindings in data attributes\n            const OIDs: VisLinkContextBinding[] = extractBinding(data[attr]) as VisLinkContextBinding[];\n\n            if (OIDs) {\n                OIDs.forEach(item => {\n                    const systemOid: StateID = item.systemOid;\n                    if (systemOid) {\n                        // Save id for subscribing\n                        !linkContext.IDs.includes(systemOid) && linkContext.IDs.push(systemOid);\n\n                        if (linkContext.byViews && !linkContext.byViews[view].includes(systemOid)) {\n                            linkContext.byViews[view].push(systemOid);\n                        }\n\n                        linkContext.bindings[systemOid] = linkContext.bindings[systemOid] || [];\n                        item.type = 'data';\n                        item.attr = attr;\n                        item.view = view;\n                        item.widget = wid;\n\n                        linkContext.bindings[systemOid].push(item);\n                    }\n                    const operation0: VisBindingOperation | undefined = item.operations && item.operations[0];\n\n                    // If we have more than one argument\n                    if (operation0 && Array.isArray(operation0.arg)) {\n                        for (let ww = 0; ww < operation0.arg.length; ww++) {\n                            const arg: VisBindingOperationArgument = operation0.arg[ww] as VisBindingOperationArgument;\n                            const _systemOid = arg.systemOid;\n                            if (!_systemOid) {\n                                continue;\n                            }\n\n                            !linkContext.IDs.includes(_systemOid) && linkContext.IDs.push(_systemOid);\n\n                            if (linkContext.byViews && !linkContext.byViews[view].includes(_systemOid)) {\n                                linkContext.byViews[view].push(_systemOid);\n                            }\n\n                            linkContext.bindings[_systemOid] = linkContext.bindings[_systemOid] || [];\n                            if (!linkContext.bindings[_systemOid].includes(item)) {\n                                linkContext.bindings[_systemOid].push(item);\n                            }\n                        }\n                    }\n                });\n            } else if (attr !== 'oidTrueValue' && attr !== 'oidFalseValue' && data[attr] && data[attr] !== 'nothing_selected') {\n                let isID = !!attr.match(/oid\\d{0,2}$/);\n                if (attr.startsWith('oid')) {\n                    isID = true;\n                } else if (attr.startsWith('signals-oid-')) {\n                    isID = true;\n                } else if (linkContext.widgetAttrInfo) {\n                    const _attr = attr.replace(/\\d{0,2}$/, '');\n                    if ((linkContext.widgetAttrInfo[_attr] as RxWidgetInfoAttributesFieldID)?.type === 'id' && (linkContext.widgetAttrInfo[_attr] as RxWidgetInfoAttributesFieldID).noSubscribe !== true) {\n                        isID = true;\n                    }\n                }\n\n                if (isID) {\n                    if (!data[attr].startsWith('\"')) {\n                        if (!linkContext.IDs.includes(data[attr])) {\n                            linkContext.IDs.push(data[attr]);\n                        }\n                        if (linkContext.byViews && !linkContext.byViews[view].includes(data[attr])) {\n                            linkContext.byViews[view].push(data[attr]);\n                        }\n                    }\n\n                    // Visibility binding\n                    if (attr === 'visibility-oid') {\n                        let vid = data['visibility-oid'];\n\n                        if (widget.grouped) {\n                            const vGroup = getWidgetGroup(views, view, wid);\n                            if (vGroup) {\n                                if (views[view].widgets[vGroup]) {\n                                    const result1 = replaceGroupAttr(vid, views[view].widgets[vGroup].data);\n                                    if (result1.doesMatch) {\n                                        vid = result1.newString;\n                                    }\n                                } else {\n                                    console.warn(`Invalid group: ${vGroup} in ${view} / ${wid}`);\n                                }\n                            }\n                        }\n\n                        linkContext.visibility[vid] = linkContext.visibility[vid] || [];\n                        linkContext.visibility[vid].push({ view, widget: wid });\n                    } else if (attr.startsWith('signals-oid-')) {\n                        // Signal binding\n                        let sid = data[attr];\n                        if (widget.grouped) {\n                            const group = getWidgetGroup(views, view, wid);\n                            if (group) {\n                                const result2 = replaceGroupAttr(sid, views[view].widgets[group].data);\n                                if (result2.doesMatch) {\n                                    sid = result2.newString;\n                                }\n                            }\n                        }\n\n                        linkContext.signals[sid] = linkContext.signals[sid] || [];\n\n                        linkContext.signals[sid].push({\n                            view,\n                            widget: wid,\n                            index: parseInt(attr.substring(12), 10), // 'signals-oid-'.length = 12\n                        });\n                    } else if (attr === 'lc-oid') {\n                        let lcSid = data[attr];\n\n                        if (widget.grouped) {\n                            const gGroup = getWidgetGroup(views, view, wid);\n                            if (gGroup) {\n                                const result3 = replaceGroupAttr(lcSid, views[view].widgets[gGroup].data);\n                                if (result3.doesMatch) {\n                                    lcSid = result3.newString;\n                                }\n                            }\n                        }\n\n                        linkContext.lastChanges[lcSid] = linkContext.lastChanges[lcSid] || [];\n                        linkContext.lastChanges[lcSid].push({ view, widget: wid });\n                    }\n                } else if (data[attr] === 'id') {\n                    m = attr.match(/^attrType(\\d+)$/);\n                    if (m) {\n                        const _id = `groupAttr${m[1]}`;\n                        if (data[_id]) {\n                            if (!linkContext.IDs.includes(data[_id])) {\n                                linkContext.IDs.push(data[_id]);\n                            }\n                            if (linkContext.byViews && !linkContext.byViews[view].includes(data[_id])) {\n                                linkContext.byViews[view].push(data[_id]);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    });\n\n    // build bindings for styles\n    if (style) {\n        Object.keys(style).forEach(cssAttr => {\n            const styleValue = (style as Record<string, any>)[cssAttr];\n            if (cssAttr && styleValue && typeof styleValue === 'string') {\n                const OIDs: VisLinkContextBinding[] = extractBinding(styleValue) as VisLinkContextBinding[];\n                if (OIDs) {\n                    OIDs.forEach(item => {\n                        const systemOid = item.systemOid;\n                        if (systemOid) {\n                            !linkContext.IDs.includes(systemOid) && linkContext.IDs.push(systemOid);\n                            if (linkContext.byViews && linkContext.byViews[view].includes(systemOid)) {\n                                linkContext.byViews[view].push(systemOid);\n                            }\n\n                            linkContext.bindings[systemOid] = linkContext.bindings[systemOid] || [];\n\n                            item.type = 'style';\n                            item.attr = cssAttr;\n                            item.view = view;\n                            item.widget = wid;\n\n                            linkContext.bindings[systemOid].push(item);\n                        }\n\n                        const operation0: VisBindingOperation | undefined = item.operations && item.operations[0];\n\n                        if (operation0 && Array.isArray(operation0.arg)) {\n                            for (let w = 0; w < operation0.arg.length; w++) {\n                                const arg: VisBindingOperationArgument = operation0.arg[w] as VisBindingOperationArgument;\n                                const _systemOid = arg.systemOid;\n                                if (!_systemOid) {\n                                    continue;\n                                }\n\n                                !linkContext.IDs.includes(_systemOid) && linkContext.IDs.push(_systemOid);\n\n                                if (linkContext.byViews && !linkContext.byViews[view].includes(_systemOid)) {\n                                    linkContext.byViews[view].push(_systemOid);\n                                }\n                                linkContext.bindings[_systemOid] = linkContext.bindings[_systemOid] || [];\n                                if (!linkContext.bindings[_systemOid].includes) {\n                                    linkContext.bindings[_systemOid].push(item);\n                                }\n                            }\n                        }\n                    });\n                }\n            }\n        });\n    }\n\n    // as we are fixing the widget in this method, write it back to store\n    store.dispatch(updateWidget({ viewId: view, widgetId: wid, data: widget }));\n}\n\nfunction getUsedObjectIDs(views: Project, isByViews?: boolean): VisStateUsage | null {\n    if (!views) {\n        console.log('Check why views are not yet loaded!');\n        return null;\n    }\n\n    const linkContext: VisStateUsage = {\n        IDs: [],\n        visibility: {},\n        bindings: {},\n        lastChanges: {},\n        signals: {},\n    };\n\n    if (isByViews) {\n        linkContext.byViews = {};\n    }\n\n    Object.keys(views).forEach(view => {\n        if (view === '___settings') {\n            return;\n        }\n\n        if (linkContext.byViews) {\n            linkContext.byViews[view] = [];\n        }\n\n        Object.keys(views[view].widgets).forEach(wid => getUsedObjectIDsInWidget(views, view, wid as AnyWidgetId, linkContext));\n    });\n\n    if (isByViews) {\n        let changed;\n        do {\n            changed = false;\n            // Check containers\n            // eslint-disable-next-line no-loop-func\n            Object.keys(views).forEach(view => {\n                if (view === '___settings') {\n                    return;\n                }\n\n                Object.values(views[view].widgets).forEach(widget => {\n                    // Add all OIDs from this view to parent\n                    if (widget.tpl === 'tplContainerView' && widget.data.contains_view && linkContext.byViews) {\n                        const ids = linkContext.byViews[widget.data.contains_view];\n                        if (ids) {\n                            for (const id of ids) {\n                                if (id && !linkContext.byViews[view].includes(id)) {\n                                    linkContext.byViews[view].push(id);\n                                    changed = true;\n                                }\n                            }\n                        } else {\n                            console.warn(`View does not exist: \"${widget.data.contains_view}\"`);\n                        }\n                    }\n                });\n            });\n        } while (changed);\n    }\n\n    return linkContext;\n}\n\nfunction getUrlParameter(attr: string): string | true {\n    const sURLVariables = window.location.search.substring(1).split('&');\n\n    for (let i = 0; i < sURLVariables.length; i++) {\n        const sParameterName = sURLVariables[i].split('=');\n\n        if (sParameterName[0] === attr) {\n            return typeof sParameterName[1] === 'undefined' ? true : decodeURIComponent(sParameterName[1]);\n        }\n    }\n\n    return '';\n}\n\nasync function readFile(socket: LegacyConnection, id: string, fileName: string, withType?: boolean): Promise<string | { file: string; mimeType: string }> {\n    const file = await socket.readFile(id, fileName);\n    let mimeType = '';\n    let data = '';\n    if (typeof file === 'object') {\n        if (withType) {\n            // @ts-expect-error LegacyConnection delivers file.mimeType\n            mimeType = file.mimeType ? file.mimeType : (file.type ? file.type : '');\n        }\n        // @ts-expect-error LegacyConnection delivers file.data\n        data = file.file || file.data;\n    } else {\n        data = file;\n    }\n    if (withType) {\n        return { file: data, mimeType };\n    }\n    return data;\n}\n\nfunction addClass(actualClass: string, toAdd: string | undefined): string {\n    if (actualClass) {\n        const parts = actualClass.split(' ').map(cl => cl.trim()).filter(cl => cl);\n        if (toAdd && !parts.includes(toAdd)) {\n            parts.push(toAdd);\n        }\n        return parts.join(' ');\n    }\n\n    return toAdd || '';\n}\n\nfunction removeClass(actualClass: string, toRemove: string): string {\n    if (actualClass) {\n        const parts = actualClass.split(' ').map(cl => cl.trim()).filter(cl => cl);\n        const pos = parts.indexOf(toRemove);\n        if (pos !== -1) {\n            parts.splice(pos, 1);\n        }\n        return parts.join(' ');\n    }\n\n    return '';\n}\n\nfunction parseDimension(field: string | number | null | undefined): { value: number; dimension: string } {\n    const result = { value: 0, dimension: 'px' };\n    if (!field) {\n        return result;\n    }\n    const match = field.toString().match(/^([0-9-.]+)([a-z%]*)$/);\n    if (!match) {\n        return result;\n    }\n    result.value = parseInt(match[1]);\n    result.dimension = match[2] || 'px';\n    return result;\n}\n\nfunction findWidgetUsages(\n    views: Project,\n    view: string,\n    widgetId: AnyWidgetId,\n    _result: { view: string; wid: AnyWidgetId; attr: string }[],\n): { view: string; wid: AnyWidgetId; attr: string }[] {\n    if (view) {\n        _result = _result || [];\n        // search in specific view\n\n        Object.keys(views[view].widgets).forEach(wid => {\n            if (wid === widgetId) {\n                return;\n            }\n            const oWidget = views[view].widgets[wid as AnyWidgetId];\n            const attrs = Object.keys(oWidget.data);\n            attrs.forEach(attr => {\n                if (attr.startsWith('widget') && oWidget.data[attr] === widgetId) {\n                    _result.push({ view, wid: wid as AnyWidgetId, attr });\n                }\n            });\n        });\n        return _result;\n    }\n\n    // search in all views\n    const result: { view: string; wid: AnyWidgetId; attr: string }[] = [];\n    Object.keys(views).forEach(_view => _view !== '___settings' && findWidgetUsages(views, _view, widgetId, _result));\n    return result;\n}\n\nexport {\n    getUsedObjectIDs,\n    extractBinding,\n    getWidgetGroup,\n    replaceGroupAttr,\n    getUsedObjectIDsInWidget,\n    getUrlParameter,\n    parseDimension,\n    addClass,\n    removeClass,\n    readFile,\n    findWidgetUsages,\n};\n","import React from 'react';\n\nimport { type LegacyConnection } from '@iobroker/adapter-react-v5';\nimport {\n    GroupWidgetId,\n    Project,\n    RxWidgetInfoGroup,\n    SingleWidgetId,\n    CustomPaletteProperties,\n    RxWidgetInfoAttributesField, RxWidgetAttributeType,\n    WidgetData,\n    RxWidgetInfoCustomComponentProperties,\n} from '@/types';\nimport VisRxWidget from '@/Vis/visRxWidget';\n\nimport { getRemoteWidgets } from './visLoadWidgets';\n// eslint-disable-next-line import/no-cycle\nimport WIDGETS from './Widgets';\n\nconst DEFAULT_SET_COLORS: Record<string, string> = {\n    basic: '#f1f1f1',\n    bars: '#f6594e',\n    dwd: '#cb8928',\n    echarts: '#98B1C0',\n    eventlist: '#c52699',\n    hqwidgets: '#005067',\n    jqplot: '#00e753',\n    jqui: '#008be0',\n    metro: '#9f8ad8',\n    swipe: '#858585',\n    tabs: '#00d5a3',\n    'spotify-premium': '#00ae03',\n};\n\ntype RxWidgetInfoAttributesFieldAll = {\n    /** Field type */\n    type?: RxWidgetAttributeType;\n    /** Field default value */\n    default?: string | number | boolean;\n    /** if true, no edit button will be shown. Default is true. */\n    readonly noButton?: boolean;\n    /** if true, the text will not be translated  */\n    readonly noTranslation?: boolean;\n    /** this style will be applied to the text */\n    readonly style?: React.CSSProperties;\n    /** show multi-line editor */\n    readonly multiline?: boolean;\n    /** Do not write 'nothing_selected' into the field by creation */\n    readonly noInit?: boolean;\n    /** Do not subscribe on changes of the object */\n    readonly noSubscribe?: boolean;\n    /** Filter of objects (not JSON string, it is an object), like:\n     - `{common: {custom: true}}` - show only objects with some custom settings\n     - `{common: {custom: 'sql.0'}}` - show only objects with sql.0 custom settings (only of the specific instance)\n     - `{common: {custom: '_dataSources'}}` - show only objects of adapters `influxdb' or 'sql' or 'history'\n     - `{common: {custom: 'adapterName.'}}` - show only objects of the custom settings for specific adapter (all instances)\n     - `{type: 'channel'}` - show only channels\n     - `{type: ['channel', 'device']}` - show only channels and devices\n     - `{common: {type: 'number'}` - show only states of type 'number\n     - `{common: {type: ['number', 'string']}` - show only states of type 'number and string\n     - `{common: {role: 'switch']}` - show only states with roles starting from switch\n     - `{common: {role: ['switch', 'button]}` - show only states with roles starting from `switch` and `button`\n     */\n    filter?: {\n        readonly common?: {\n            readonly custom?: true | string | '_dataSources';\n            readonly type?: ioBroker.CommonType | ioBroker.CommonType[];\n            readonly role?: string | string[];\n        };\n        readonly type?: ioBroker.ObjectType | ioBroker.ObjectType[];\n    } | string;\n    /** Additionally, you can provide `adapter` to filter the instances of specific adapter. With special adapter name `_dataSources` you can get all adapters with flag `common.getHistory`. */\n    readonly adapter?: string;\n    /** In this case, only instance number (like `0`) is shown and not `history.0`. It can be set to true only with non-empty `adapter` setting. */\n    readonly iShort?: boolean;\n    /** Options for a select type */\n    options?: { readonly value: string; label: string }[] | string[];\n    /** Number min value */\n    min?: number;\n    /** Number max value */\n    max?: number;\n    /** Number step */\n    step?: number;\n    /** Slider marks?: array of possible marks. Like `[{value: 1, label: 'one'}, {value: 10}, {value: 100}] */\n    readonly marks?: { readonly value: number; label: string }[];\n    /** Controls when the value label is displayed: `auto` the value label will display when the thumb is hovered or focused. `on` will display persistently. `off` will never display. */\n    readonly valueLabelDisplay?: 'on' | 'off' | 'auto';\n    /** type of the widget, like `tplMaterial2Switches` */\n    readonly tpl?: string;\n    /** if true, all widgets of all views will be shown, not only from the current view. Default is false. */\n    readonly all?: boolean;\n    /**  if true, grouped widgets will be shown too. Default is false. */\n    readonly withGroups?: boolean;\n    /** if true, the current widget will be shown in the list too. */\n    readonly withSelf?: boolean;\n    /** if true, it will be checked if the widget is used somewhere else and user will be asked. */\n    readonly checkUsage?: boolean;\n    /** if true, only widgets will be shown, which are not used in some view. Default is false. */\n    readonly hideUsed?: boolean;\n    /** if false, only one view can be selected. Default is true. */\n    readonly multiple?: boolean;\n    /** if false, only one view can be selected. Default is true. */\n    component?: (\n        field: RxWidgetInfoAttributesField,\n        data: WidgetData,\n        onDataChange: (newData: WidgetData) => void,\n        props: RxWidgetInfoCustomComponentProperties,\n    ) => React.JSX.Element | React.JSX.Element[];\n\n    /** Name of the widget field */\n    name: string;\n    /** Field label (i18n) */\n    label?: string;\n    /** JS Function for conditional visibility */\n    hidden?: string | ((data: any) => boolean) | ((data: any, index: number) => boolean);\n    /** Tooltip (i18n) */\n    tooltip?: string;\n    /** JS Function for conditional disability */\n    disabled?: string | ((data: any) => boolean) | ((data: any, index: number) => boolean);\n    /** JS Function for error */\n    error?: string | ((data: any) => boolean) | ((data: any, index: number) => boolean);\n    /** Do not show binding symbol fot this field */\n    readonly noBinding?: boolean;\n    /** Callback called if the field value changed */\n    onChange?: (field: RxWidgetInfoAttributesField, data: Record<string, any>, changeData: (newData: Record<string, any>) => void, socket: LegacyConnection, index?: number) => Promise<void> | string;\n}\n\ninterface WidgetAttributeInfoStored extends RxWidgetInfoAttributesFieldAll {\n    onChangeFunc?: string;\n    filterFile?: string;\n    filterName?: string;\n    filterAttrs?: string;\n    removeName?: string;\n    singleName?: string;\n    set?: string;\n    index?: number;\n    indexFrom?: string | number;\n    indexTo?: string | number;\n    iterable?: {\n        group: string;\n        isFirst: boolean;\n        isLast: boolean;\n        indexTo: number | string | undefined;\n        indexFrom: number | string | undefined;\n    };\n}\n\ninterface WidgetAttributesGroupInfoStored {\n    name?: string;\n    label?: string;\n    singleName?: string;\n    index?: number;\n    fields?: RxWidgetInfoAttributesFieldAll[];\n    indexFrom?: number | string;\n    indexTo?: number | string;\n    iterable?: {\n        group: string;\n        isFirst: boolean;\n        isLast: boolean;\n        indexTo: number | string | undefined;\n        indexFrom: number | string | undefined;\n    };\n}\n\nexport interface WidgetType {\n    name: string;\n    title?: string;\n    label?: string;\n    preview?: string;\n    help?: string;\n    set?: string;\n    imageHTML?: string;\n    init?: string;\n    color?: string;\n    resizable?: boolean;\n    resizeLocked?: boolean;\n    draggable?: boolean;\n    params: string | readonly RxWidgetInfoGroup[];\n\n    setLabel?: string;\n    setColor?: string;\n    setIcon?: string;\n\n    order?: number;\n    hidden?: boolean;\n    style?: React.CSSProperties;\n    customPalette?: (context: CustomPaletteProperties) => React.JSX.Element;\n\n    adapter?: string;\n    version?: string;\n    rx?: boolean;\n    developerMode?: boolean;\n    i18nPrefix?: string;\n}\n\ninterface VisRxWidgetLoaded extends VisRxWidget<any> {\n    readonly i18nPrefix?: string | undefined;\n    readonly adapter?: string;\n    readonly version?: string;\n    readonly visHidden?: boolean;\n    readonly url?: string;\n}\n\nclass VisWidgetsCatalog {\n    static rxWidgets: Record<string, VisRxWidgetLoaded> | null = null;\n\n    static allWidgetsList: string[] | null = null;\n\n    static getUsedWidgetSets(project: Project): string[] | false {\n        let anyWithoutSet = false;\n        const widgetSets: string[] = [];\n\n        // load in runtime only used widget sets\n        const views = Object.keys(project);\n        for (let v = 0; v < views.length; v++) {\n            if (views[v] === '___settings') {\n                continue;\n            }\n            const widgets = project[views[v]].widgets;\n            const keys: (GroupWidgetId | SingleWidgetId)[] = Object.keys(widgets) as (GroupWidgetId | SingleWidgetId)[];\n            for (let w = 0; w < keys.length; w++) {\n                const widgetSet = widgets[keys[w]].widgetSet;\n                if (!widgetSet || widgets[keys[w]].set || widgets[keys[w]].wSet) {\n                    anyWithoutSet = true;\n                    break;\n                }\n                if (!widgetSets.includes(widgetSet)) {\n                    widgetSets.push(widgetSet);\n                }\n            }\n            if (anyWithoutSet) {\n                console.warn('Found widgets without widget set. Will load all widget sets');\n                break;\n            }\n        }\n        !anyWithoutSet && widgetSets.sort();\n\n        return anyWithoutSet ? false : widgetSets;\n    }\n\n    static setUsedWidgetSets(project: Project) {\n        // provide for all widgets the widget set and set\n        let views;\n        const widgetTypes = (window as any).visWidgetTypes as WidgetType[]; // getWidgetTypes();\n        const viewKeys = Object.keys(project);\n\n        for (let v = 0; v < viewKeys.length; v++) {\n            if (viewKeys[v] === '___settings') {\n                continue;\n            }\n            const widgets = project[viewKeys[v]].widgets;\n            const keys: (GroupWidgetId | SingleWidgetId)[] = Object.keys(widgets) as (GroupWidgetId | SingleWidgetId)[];\n            for (let w = 0; w < keys.length; w++) {\n                // remove deprecated attributes\n                if (widgets[keys[w]].set) {\n                    views = views || JSON.parse(JSON.stringify(project));\n                    delete views[viewKeys[v]].widgets[keys[w]].set;\n                }\n                if (widgets[keys[w]].wSet) {\n                    views = views || JSON.parse(JSON.stringify(project));\n                    delete views[viewKeys[v]].widgets[keys[w]].wSet;\n                }\n                if (widgets[keys[w]].widgetSet) {\n                    continue;\n                }\n                const tpl = widgets[keys[w]].tpl;\n\n                if (tpl === '_tplGroup') {\n                    views = views || JSON.parse(JSON.stringify(project));\n                    views[viewKeys[v]].widgets[keys[w]].widgetSet = 'basic';\n                } else {\n                    const tplWidget = widgetTypes.find(item => item.name === tpl);\n                    if (tplWidget) {\n                        views = views || JSON.parse(JSON.stringify(project));\n                        views[viewKeys[v]].widgets[keys[w]].widgetSet = tplWidget.set;\n                    }\n                }\n            }\n        }\n\n        return views;\n    }\n\n    static collectRxInformation(\n        socket: LegacyConnection,\n        project: Project,\n        changeProject?: (newProject: Project) => void,\n    ): Promise<Record<string, VisRxWidget<any>>> {\n        if (!VisWidgetsCatalog.rxWidgets) {\n            VisWidgetsCatalog.rxWidgets = {};\n            // collect all widget sets used in a project\n            let usedWidgetSets: string[] | false | null = null;\n            if (project) {\n                usedWidgetSets = VisWidgetsCatalog.getUsedWidgetSets(project);\n            }\n\n            return new Promise(resolve => {\n                setTimeout(() =>\n                    getRemoteWidgets(socket, !changeProject && usedWidgetSets ? usedWidgetSets : false)\n                        .then((widgetSets: void | VisRxWidget<any>[]) => {\n                            const collectedWidgets: VisRxWidget<any>[] = [...WIDGETS, ...(widgetSets || [])] as VisRxWidget<any>[];\n\n                            collectedWidgets.forEach((Widget: VisRxWidget<any>) => {\n                                if (!Widget?.getWidgetInfo) {\n                                    console.error(`Invalid widget without getWidgetInfo: ${Widget.constructor.name}`);\n                                } else {\n                                    const info = Widget.getWidgetInfo();\n                                    if (!info.visSet) {\n                                        console.error(`No visSet in info for \"${Widget.constructor.name}\"`);\n                                    }\n\n                                    if (!info.id) {\n                                        console.error(`No id in info for \"${Widget.constructor.name}\"`);\n                                    } else if (VisWidgetsCatalog.rxWidgets) {\n                                        VisWidgetsCatalog.rxWidgets[info.id] = Widget;\n                                    }\n                                }\n                            });\n\n                            // init all widgets\n                            if (changeProject) {\n                                // eslint-disable-next-line no-use-before-define\n                                getWidgetTypes();\n                            } else if (usedWidgetSets) {\n                                // eslint-disable-next-line no-use-before-define\n                                getWidgetTypes(usedWidgetSets);\n                            } else {\n                                // eslint-disable-next-line no-use-before-define\n                                getWidgetTypes();\n                            }\n\n                            if (usedWidgetSets === false && changeProject) {\n                                // some widgets without set found\n                                const newProject = VisWidgetsCatalog.setUsedWidgetSets(project);\n                                if (newProject) {\n                                    console.warn('Found widgets without widget set. Project updated');\n                                    changeProject(newProject);\n                                }\n                            }\n\n                            resolve(VisWidgetsCatalog.rxWidgets as Record<string, VisRxWidget<any>>);\n                        }), 0);\n            });\n        }\n\n        return Promise.resolve(VisWidgetsCatalog.rxWidgets);\n    }\n}\n\nexport const getWidgetTypes: (_usedWidgetSets?: string[]) => WidgetType[] = (usedWidgetSets?: string[]) => {\n    if (!(window as any).visWidgetTypes) {\n        (window as any).visSets = {};\n        VisWidgetsCatalog.allWidgetsList = [];\n\n        if (!VisWidgetsCatalog.rxWidgets) {\n            return [];\n        }\n\n        // Old CanJS widgets\n        (window as any).visWidgetTypes = Array.from(document.querySelectorAll('script[type=\"text/ejs\"]'))\n            .map(script => {\n                const name: string | null = script.getAttribute('id');\n                if (!name || !VisWidgetsCatalog.rxWidgets) {\n                    return null;\n                }\n                // only if RX widget with the same name not found\n                let info;\n                // @ts-expect-error we must check getWidgetInfo\n                if (VisWidgetsCatalog.rxWidgets[name]?.getWidgetInfo) {\n                    info = VisWidgetsCatalog.rxWidgets[name].getWidgetInfo();\n                    if (info?.visAttrs && typeof info.visAttrs !== 'string') {\n                        return null;\n                    }\n                }\n\n                const widgetSet = script.getAttribute('data-vis-set') || 'basic';\n                if (usedWidgetSets && !usedWidgetSets.includes(widgetSet)) {\n                    console.log(`Ignored ${widgetSet}/${name} because not used in project`);\n                    return null;\n                }\n\n                const color = script.getAttribute('data-vis-color');\n                (window as any).visSets[widgetSet] = (window as any).visSets[widgetSet] || {};\n                if (color) {\n                    (window as any).visSets[widgetSet].color = color;\n                } else if (!(window as any).visSets[widgetSet].color && DEFAULT_SET_COLORS[widgetSet]) {\n                    (window as any).visSets[widgetSet].color = DEFAULT_SET_COLORS[widgetSet];\n                }\n                const widgetObj: WidgetType = {\n                    name,\n                    title: info?.visName || script.getAttribute('data-vis-name') || undefined,\n                    label: info?.visWidgetLabel || info?.visWidgetLabel === '' ? info.visWidgetLabel : undefined, // new style with translation\n                    preview: info?.visPrev || script.getAttribute('data-vis-prev') || undefined,\n                    help: script.getAttribute('data-vis-help') || undefined,\n                    set: info?.visSet || widgetSet,\n                    imageHTML: script.getAttribute('data-vis-prev') || '',\n                    init: script.getAttribute('data-vis-init') || undefined,\n                    color: info?.visWidgetColor || undefined,\n                    params: info?.visAttrs || Object.values(script.attributes)\n                        .filter(attribute => attribute.name.startsWith('data-vis-attrs'))\n                        .map(attribute => attribute.value)\n                        .join(''),\n                    setLabel: info?.visSetLabel || undefined,\n                    setColor: info?.visSetColor || undefined,\n                    order: info?.visOrder === undefined || info?.visOrder === null ? 1000 : (typeof info.visOrder === 'string' ? parseInt(info.visOrder, 10) : info.visOrder),\n                    hidden: script.getAttribute('data-vis-no-palette') === 'true',\n                };\n\n                VisWidgetsCatalog.allWidgetsList?.push(widgetObj.name);\n\n                return widgetObj;\n            }).filter(w => w);\n\n        // React widgets\n        // We have here two types of widgets: native (from this repository - function) and loaded via getRemoteWidgets (objects)\n        const widgets = Object.values(VisWidgetsCatalog.rxWidgets) as VisRxWidgetLoaded[];\n        widgets.forEach(widget => {\n            const widgetInfo = widget.getWidgetInfo();\n            const i18nPrefix = widget.i18nPrefix || '';\n\n            const widgetObj: WidgetType = {\n                name: widgetInfo.id,\n                preview: widgetInfo.visPrev,\n                title: widgetInfo.visName, // old style without translation\n                params: widgetInfo.visAttrs,\n                set: widgetInfo.visSet,\n                style: widgetInfo.visDefaultStyle,\n                label: widgetInfo.visWidgetLabel ? i18nPrefix + widgetInfo.visWidgetLabel : (widgetInfo.visWidgetLabel === '' ? '' : undefined), // new style with translation\n                setLabel: widgetInfo.visSetLabel ? i18nPrefix + widgetInfo.visSetLabel : undefined, // new style with translation\n                setColor: widgetInfo.visSetColor,\n                setIcon: widgetInfo.visSetIcon,\n                color: widgetInfo.visWidgetColor,\n                resizable: widgetInfo.visResizable,\n                resizeLocked: widgetInfo.visResizeLocked,\n                draggable: widgetInfo.visDraggable,\n                adapter: widget.adapter || undefined,\n                version: widget.version || undefined,\n                hidden: widget.visHidden,\n                order: widgetInfo.visOrder === undefined ? 1000 : widgetInfo.visOrder,\n                // custom: widgetInfo.custom, not used\n                customPalette: widgetInfo.customPalette,\n                rx: true,\n                developerMode: widget.url?.startsWith('http://'),\n                i18nPrefix,\n            };\n            VisWidgetsCatalog.allWidgetsList && !VisWidgetsCatalog.allWidgetsList.includes(widgetObj.name) && VisWidgetsCatalog.allWidgetsList.push(widgetObj.name);\n\n            const index = (window as any).visWidgetTypes.findIndex((item: WidgetType) => item.name === widgetObj.name);\n            if (index > -1) {\n                (window as any).visWidgetTypes[index] = widgetObj; // replace old widget with RX widget\n            } else {\n                (window as any).visWidgetTypes.push(widgetObj);\n            }\n\n            if (i18nPrefix && typeof widgetInfo.visAttrs === 'object') {\n                widgetInfo.visAttrs.forEach(group => {\n                    if (group.label && !group.label.startsWith(i18nPrefix)) {\n                        (group as WidgetAttributesGroupInfoStored).label = i18nPrefix + group.label;\n                    }\n                    if (group.fields) {\n                        group.fields.forEach(field => {\n                            const _field = field as unknown as WidgetAttributeInfoStored;\n                            if (_field.label && !_field.label.startsWith(i18nPrefix)) {\n                                _field.label = i18nPrefix + _field.label;\n                            }\n                            if (_field.tooltip && !_field.tooltip.startsWith(i18nPrefix)) {\n                                _field.tooltip = i18nPrefix + _field.tooltip;\n                            }\n                            if (_field.options && !_field.noTranslation && Array.isArray(_field.options)) {\n                                _field.options.forEach(option => {\n                                    if (typeof option === 'object') {\n                                        if (option.label && !option.label.startsWith(i18nPrefix)) {\n                                            option.label = i18nPrefix + option.label;\n                                        }\n                                    }\n                                });\n                            }\n                        });\n                    }\n                });\n            }\n        });\n    }\n\n    return (window as any).visWidgetTypes;\n};\n\nconst deepClone = (obj: any[] | Record<string, any>) => {\n    if (Array.isArray(obj)) {\n        const newObj: any[] = [];\n        for (const key in obj as any[]) {\n            if (obj[key] !== undefined) {\n                if (Array.isArray(obj[key]) || typeof obj[key] === 'object') {\n                    // If it is ReactJS object\n                    if (Object.prototype.hasOwnProperty.call(obj, '$$typeof')) {\n                        newObj[key] = obj[key];\n                    } else {\n                        newObj[key] = deepClone(obj[key]);\n                    }\n                } else {\n                    newObj[key] = obj[key];\n                }\n            }\n        }\n        return newObj;\n    }\n\n    const newObj: Record<string, any> = {};\n    for (const key in obj as Record<string, any>) {\n        if (obj[key] !== undefined) {\n            if (Array.isArray(obj[key]) || typeof obj[key] === 'object') {\n                // If it is ReactJS object\n                if (Object.prototype.hasOwnProperty.call(obj, '$$typeof')) {\n                    newObj[key] = obj[key];\n                } else {\n                    newObj[key] = deepClone(obj[key]);\n                }\n            } else {\n                newObj[key] = obj[key];\n            }\n        }\n    }\n    return newObj;\n};\n\ninterface CommonGroups {\n    common: number;\n    [key: string]: number;\n}\n\nexport const parseAttributes = (\n    widgetParams: string | RxWidgetInfoGroup[],\n    widgetIndex?: number,\n    commonGroups?: CommonGroups,\n    commonFields?: Record<string, any>,\n    widgetSet?: string,\n    widgetData?: Record<string, any>,\n) => {\n    if (typeof widgetParams === 'string') {\n        let groupName = 'common';\n        let indexedGroups: { [key: number]: WidgetAttributesGroupInfoStored } = {};\n        let isIndexedGroup = false;\n        commonGroups = commonGroups || { common: 1 };\n        commonFields = commonFields || {};\n        const fields: WidgetAttributesGroupInfoStored[] = [{\n            name: 'common',\n            singleName: 'common',\n            fields: [],\n        }];\n        let currentGroup: WidgetAttributesGroupInfoStored | undefined = fields[0];\n        widgetIndex = widgetIndex || 0;\n\n        widgetParams.split(';').forEach(fieldString => {\n            if (!fieldString) {\n                return;\n            }\n\n            if (fieldString.split('/')[0].startsWith('group.')) {\n                groupName = fieldString.split('/')[0].split('.')[1];\n                if (widgetIndex !== undefined && widgetIndex > 0 && commonGroups && !commonGroups[groupName]) {\n                    return;\n                }\n                indexedGroups = {};\n                if (fieldString.split('/')[1] !== 'byindex') {\n                    currentGroup = fields.find(group => group.name === groupName);\n                    if (!currentGroup) {\n                        fields.push(\n                            {\n                                name: groupName,\n                                singleName: groupName,\n                                fields: [],\n                            },\n                        );\n                        currentGroup = fields[fields.length - 1];\n                    }\n                    if (commonGroups) {\n                        if (!commonGroups[groupName]) {\n                            commonGroups[groupName] = 0;\n                        }\n                        commonGroups[groupName]++;\n                    }\n                    isIndexedGroup = false;\n                } else {\n                    isIndexedGroup = true;\n                }\n            } else {\n                const match = fieldString.match(/([a-zA-Z0-9._-]+)(\\([a-zA-Z.0-9-_]*\\))?(\\[.*])?(\\/[-_,^~\\s:/.a-zA-Z0-9]+)?/);\n                if (!match) {\n                    console.warn(`Invalid attribute ${fieldString}`);\n                    return;\n                }\n\n                const repeats = match[2];\n                let type: RxWidgetAttributeType;\n                let onChangeFunc: string | undefined;\n                if (match[4]) {\n                    const parts = match[4].substring(1).split('/');\n                    type = parts[0] as RxWidgetAttributeType;\n                    onChangeFunc = parts[1];\n                } else {\n                    type = 'text';\n                }\n                const field: WidgetAttributeInfoStored = {\n                    name: match[1],\n                    default: match[3] ? match[3].substring(1, match[3].length - 1) : undefined, // remove []\n                    type,\n                    onChangeFunc,\n                };\n\n                if (field.type) {\n                    field.type = field.type\n                        .replace(//g, ';')\n                        .replace(/~/g, '/')\n                        .replace(/\\^/g, '\"')\n                        .replace(/\\^\\^/g, '^') as RxWidgetAttributeType;\n                }\n                if (typeof field.default === 'string') {\n                    field.default = field.default\n                        .replace(//g, ';')\n                        .replace(/~/g, '/')\n                        .replace(/\\^/g, '\"')\n                        .replace(/\\^\\^/g, '^');\n                }\n\n                // special case for Object ID filter\n                if (field.onChangeFunc && field.onChangeFunc.startsWith('filterType')) {\n                    field.filter = field.onChangeFunc.substring('filterType'.length).toLowerCase();\n                    delete field.onChangeFunc;\n                }\n\n                if (widgetIndex && widgetIndex > 0 && !repeats && commonFields && !commonFields[`${groupName}.${field.name}`]) {\n                    return;\n                }\n\n                if (field.name === 'oid' || field.name.match(/^oid-/)) {\n                    field.type = field.type || 'id';\n                } else if (field.name === 'color') {\n                    field.type = 'color';\n                } else if (field.name.match(/nav_view$/)) {\n                    field.type = 'views';\n                } else if (field.name === 'sound') {\n                    // field.type = 'sound';\n                    field.type = 'text';\n                } else if (field.name.includes('_effect')) {\n                    // field.type = 'effect';\n                    field.type = 'text';\n                } else if (field.name.includes('_eff_opt')) {\n                    // field.type = 'effect-options';\n                    field.type = 'text';\n                }\n\n                if (field.type && (field.type.startsWith('id,'))) {\n                    const options = field.type.split(',');\n                    field.type = options[0] as RxWidgetAttributeType;\n                    field.filter = options[1];\n                }\n                if (field.type && (field.type.startsWith('select,') || field.type.startsWith('nselect,') || field.type.startsWith('auto,'))) {\n                    const options = field.type.split(',');\n                    field.type = options[0] as RxWidgetAttributeType;\n                    field.options = options.slice(1);\n                }\n                if (field.type && (field.type.startsWith('slider,') || field.type.startsWith('number,'))) {\n                    const options = field.type.split(',');\n                    field.type = options[0] as RxWidgetAttributeType;\n                    field.min = parseInt(options[1]);\n                    field.max = parseInt(options[2]);\n                    field.step = parseInt(options[3]);\n                    if (!field.step) {\n                        field.step = (field.max - field.min / 100);\n                    }\n                }\n                if (field.type && field.type.startsWith('style,')) {\n                    const options = field.type.split(',');\n                    field.type = options[0] as RxWidgetAttributeType;\n                    field.filterFile = options[1];\n                    field.filterName = options[2];\n                    field.filterAttrs = options[3];\n                    field.removeName = options[4];\n                    if (!field.step && field.max !== undefined && field.min !== undefined) {\n                        field.step = (field.max - field.min / 100);\n                    }\n                }\n                // remove comma from type\n                if (field.type?.startsWith('style,')) {\n                    console.warn(`Attribute \"${field.name}\" of ${widgetSet} has wrong type: ${field.type}`);\n                    field.type = field.type.split(',')[0] as RxWidgetAttributeType;\n                }\n\n                field.singleName = field.name;\n                field.set = widgetSet;\n                if (repeats) {\n                    const repeatsMatch = repeats.match(/\\(([0-9a-z_]+)-([0-9a-z_]+)\\)/i);\n                    const name = field.name;\n                    if (repeatsMatch) {\n                        let from = 1;\n                        let to = 1;\n                        if (!repeatsMatch[1].match(/^[0-9]$/)) {\n                            from = widgetData ? parseInt(widgetData[repeatsMatch[1]]) : 0;\n                        }\n                        if (!repeatsMatch[2].match(/^[0-9]$/)) {\n                            to = widgetData ? parseInt(widgetData[repeatsMatch[2]]) : 0;\n                        }\n                        for (let i = from; i <= to; i++) {\n                            if (isIndexedGroup) {\n                                if (commonGroups && widgetIndex && widgetIndex > 0 && !commonGroups[`${groupName}-${i}`]) {\n                                    return;\n                                }\n                                if (commonFields && widgetIndex && widgetIndex > 0 && !commonFields[`${groupName}-${i}.${field.name}`]) {\n                                    return;\n                                }\n                                if (!indexedGroups[i]) {\n                                    currentGroup = {\n                                        name: `${groupName}-${i}`,\n                                        singleName: groupName,\n                                        index: i,\n                                        fields: [],\n                                    };\n                                    indexedGroups[i] = currentGroup;\n                                    fields.push(currentGroup);\n                                }\n                                if (commonGroups) {\n                                    if (!commonGroups[`${groupName}-${i}`]) {\n                                        commonGroups[`${groupName}-${i}`] = 0;\n                                    }\n                                    commonGroups[`${groupName}-${i}`]++;\n                                }\n\n                                field.name = `${name}${i}`;\n                                indexedGroups[i]?.fields?.push({ ...field });\n                                if (commonFields) {\n                                    if (!commonFields[`${groupName}-${i}.${field.name}`]) {\n                                        commonFields[`${groupName}-${i}.${field.name}`] = 0;\n                                    }\n                                    commonFields[`${groupName}-${i}.${field.name}`]++;\n                                }\n                            } else {\n                                field.name = `${name}${i}`;\n                                field.index = i;\n                                currentGroup?.fields?.push({ ...field });\n                                if (commonFields) {\n                                    if (!commonFields[`${groupName}.${field.name}`]) {\n                                        commonFields[`${groupName}.${field.name}`] = 0;\n                                    }\n                                    commonFields[`${groupName}.${field.name}`]++;\n                                }\n                            }\n                        }\n                    }\n                } else {\n                    currentGroup?.fields?.push(field);\n                    if (commonFields) {\n                        if (!commonFields[`${groupName}.${field.name}`]) {\n                            commonFields[`${groupName}.${field.name}`] = 0;\n                        }\n                        commonFields[`${groupName}.${field.name}`]++;\n                    }\n                }\n            }\n        });\n\n        return fields;\n    }\n\n    if (Array.isArray(widgetParams)) {\n        commonGroups = commonGroups || { common: 1 };\n        commonFields = commonFields || {};\n        const fields = deepClone(widgetParams) as WidgetAttributesGroupInfoStored[];\n        let groupIndex = fields.findIndex(group => typeof group.indexFrom === 'number');\n\n        // if enumerable\n        while (groupIndex > -1) {\n            const group = fields[groupIndex] as WidgetAttributesGroupInfoStored;\n            group.singleName = group.name;\n            let from: number;\n            let indexFrom;\n            if (Number.isInteger(group.indexFrom)) {\n                from = group.indexFrom as number;\n            } else {\n                from = parseInt(widgetData?.[group.indexFrom || 1]);\n                indexFrom = from;\n            }\n            let to: number;\n            let indexTo;\n            if (Number.isInteger(group.indexTo)) {\n                to = parseInt((group.indexTo as string) || '1', 10);\n            } else {\n                to = parseInt(widgetData?.[group.indexTo || 1]);\n                indexTo = group.indexTo;\n            }\n            delete group.indexFrom;\n            delete group.indexTo;\n            const indexedGroups = [];\n\n            for (let i = from; i <= to; i++) {\n                const indexedGroup: WidgetAttributesGroupInfoStored = {\n                    ...deepClone(group),\n                    index: i,\n                    name: `${group.singleName}-${i}`,\n                    iterable: {\n                        group: group.singleName || '',\n                        isFirst: i === from,\n                        isLast: i === to,\n                        indexTo,\n                        indexFrom,\n                    },\n                };\n                indexedGroup.fields?.forEach((field: WidgetAttributeInfoStored, ii) => {\n                    field.singleName = field.name;\n                    field.name = `${field.name}${i}`;\n                    field.index = i;\n                    if (group.fields && group.fields[ii]) {\n                        if (typeof group.fields[ii].hidden === 'function') {\n                            field.hidden = group.fields[ii].hidden;\n                        }\n                        if (typeof group.fields[ii].component === 'function') {\n                            field.component = group.fields[ii].component;\n                        }\n                        if (typeof group.fields[ii].onChange === 'function') {\n                            field.onChange = group.fields[ii].onChange;\n                        }\n                        if (typeof group.fields[ii].disabled === 'function') {\n                            field.disabled = group.fields[ii].disabled;\n                        }\n                        if (typeof group.fields[ii].error === 'function') {\n                            field.error = group.fields[ii].error;\n                        }\n                    }\n                });\n\n                indexedGroups.push(indexedGroup);\n            }\n            fields.splice(groupIndex, 1, ...indexedGroups);\n            groupIndex = fields.findIndex(_group => _group.indexFrom);\n        }\n\n        fields.forEach(group => {\n            if (!group.name) {\n                group.name = 'common';\n            }\n            if (!group.singleName) {\n                group.singleName = group.name;\n            }\n            if (commonGroups) {\n                if (!commonGroups[group.name]) {\n                    commonGroups[group.name] = 0;\n                }\n                commonGroups[group.name]++;\n            }\n            if (group.fields) {\n                // fields can be interable too\n                let fieldIndex = group.fields.findIndex((field: WidgetAttributeInfoStored) => field.indexFrom);\n                while (fieldIndex > -1) {\n                    const field = group.fields[fieldIndex] as WidgetAttributeInfoStored;\n                    field.singleName = field.name;\n                    let from = 1;\n                    let indexFrom;\n                    if (Number.isInteger(field.indexFrom)) {\n                        from = parseInt(field.indexFrom as string, 10);\n                    } else if (typeof field.indexFrom === 'string') {\n                        from = parseInt(widgetData?.[field.indexFrom]);\n                        indexFrom = from;\n                    }\n                    let to = 1;\n                    let indexTo;\n                    if (Number.isInteger(field.indexTo)) {\n                        to = parseInt(field.indexTo as string, 10);\n                    } else if (typeof field.indexTo === 'string') {\n                        to = parseInt(widgetData?.[field.indexTo]);\n                        indexTo = field.indexTo;\n                    }\n                    delete field.indexFrom;\n                    delete field.indexTo;\n                    const indexedFields = [];\n                    for (let i = from; i <= to; i++) {\n                        const indexedField = deepClone(field) as WidgetAttributeInfoStored;\n                        indexedField.index = i;\n                        indexedField.name = `${field.singleName}${i}`;\n                        indexedField.iterable = {\n                            group: field.singleName,\n                            isFirst: i === from,\n                            isLast: i === to,\n                            indexFrom,\n                            indexTo,\n                        };\n                        indexedFields.push(indexedField);\n                    }\n\n                    group.fields?.splice(fieldIndex, 1, ...indexedFields);\n\n                    fieldIndex = group.fields.findIndex((_field: WidgetAttributeInfoStored) => _field.indexFrom);\n                }\n\n                group.fields.forEach((field: WidgetAttributeInfoStored) => {\n                    if (!field.singleName) {\n                        field.singleName = field.name;\n                    }\n                    field.set = widgetSet;\n                    if (commonFields) {\n                        if (!commonFields[`${group.name}.${field.name}`]) {\n                            commonFields[`${group.name}.${field.name}`] = 0;\n                        }\n                        commonFields[`${group.name}.${field.name}`]++;\n                    }\n                });\n            }\n        });\n\n        return fields;\n    }\n\n    return null;\n};\n\nexport default VisWidgetsCatalog;\n"],"names":["FAKE_ID","updateProject","createAction","updateView","updateWidget","updateGroupWidget","updateActiveUser","recalculateFields","reducer","createReducer","visProject","activeUser","builder","addCase","state","action","payload","viewId","data","widgetId","widgets","console","error","concat","selectView","createSelector","_state","viewName","project","view","store","_viewName","wid","configureStore","NOTHING_SELECTED","calculateOverflow","style","overflowX","overflowY","overflow","isVarFinite","numberOrString","window","isFinite","deepClone","object","JSON","parse","stringify","DEFAULT_PERMISSIONS","read","write","hasWidgetAccess","options","_project$view$widgets","_project$view2","_project$view2$widget","_project$view2$widget2","user","editMode","permissions","loadComponent","remote","sharedScope","module","url","getOrLoadRemote","shareScope","remoteFallbackUrl","Promise","resolve","reject","onload","async","startsWith","Error","__initialized","init","__webpack_share_scopes__","e","document","querySelector","warn","d","script","createElement","type","setAttribute","onerror","includes","src","getElementsByTagName","appendChild","then","get","factory","_loadComponentHelper","context","promises","i","visWidgetsCollection","components","length","index","_visWidgetsCollection","countRef","max","promise","name","CustomComponent","count","default","adapter","dynamicWidgetInstance","_id","substring","replace","version","common","i18nPrefix","result","push","__widgetsLoadIndicator","catch","toString","all","getRemoteWidgets","socket","onlyWidgetSets","getObjectViewSystem","objects","dynamicWidgetInstances","Object","values","filter","obj","visWidgets","ignoreInVersions","text","I18n","getLanguage","en","widgetSetName","_widgetSetName","keys","find","_visWidgetsCollection2","collection","instance","i18nPromiseWait","i18n","pos","lastIndexOf","i18nURL","lang","fetch","json","extendTranslations","_error","log","translations","prefix","replaceGroupAttr","inputStr","groupAttrList","newString","match","ms","forEach","m","val","undefined","attr","doesMatch","getWidgetGroup","views","widget","_widgets$widget","groupId","groupid","w","_widgets$w$data","_widgets$w$data$membe","members","extractBinding","format","oid","p","_oid","parts","split","systemOid","trim","visOid","test1","test2","isSeconds","operations","xx","yy","op","arg","u","trimmed","_operations$0$arg","argParts","_visOid","_systemOid","formula","n","argStr","parseFloat","param","token","getUsedObjectIDsInWidget","linkContext","groupped","grouped","widgetSet","tpl","value","html_false","html_closed","html_true","html_open","value0","value1","value2","html_tilt","readOnly","orientation","dispatch","getState","groupNum","gId","padStart","currView","top","left","width","height","_views$view$widgets$w","parentWidgetData","newGroupData","OIDs","item","IDs","byViews","bindings","operation0","Array","isArray","ww","isID","widgetAttrInfo","_linkContext$widgetAt","_attr","noSubscribe","vid","vGroup","result1","visibility","sid","group","result2","signals","parseInt","lcSid","gGroup","result3","lastChanges","cssAttr","styleValue","addClass","actualClass","toAdd","map","cl","join","removeClass","toRemove","indexOf","splice","parseDimension","field","dimension","DEFAULT_SET_COLORS","basic","bars","dwd","echarts","eventlist","hqwidgets","jqplot","jqui","metro","swipe","tabs","VisWidgetsCatalog","getUsedWidgetSets","anyWithoutSet","widgetSets","v","set","wSet","sort","setUsedWidgetSets","widgetTypes","visWidgetTypes","viewKeys","tplWidget","collectRxInformation","changeProject","rxWidgets","usedWidgetSets","setTimeout","WIDGETS","Widget","getWidgetInfo","info","visSet","constructor","id","getWidgetTypes","newProject","allWidgetsList","visSets","from","querySelectorAll","_VisWidgetsCatalog$rx","_info2","_info3","_info4","_info5","_info6","_info7","_info8","_info9","_info10","_info11","_info12","_VisWidgetsCatalog$al","getAttribute","_info","visAttrs","color","widgetObj","title","visName","label","visWidgetLabel","preview","visPrev","help","imageHTML","visWidgetColor","params","attributes","attribute","setLabel","visSetLabel","setColor","visSetColor","order","visOrder","hidden","_widget$url","widgetInfo","visDefaultStyle","setIcon","visSetIcon","resizable","visResizable","resizeLocked","visResizeLocked","draggable","visDraggable","visHidden","customPalette","rx","developerMode","findIndex","fields","_field","tooltip","noTranslation","option"],"sourceRoot":""}